# -*- coding: utf-8 -*-
# @Time    : 2021.5.2
# @Author  : Aman

from collections import defaultdict
from tqdm import tqdm
import pickle
import re


class Retrieval():
    
    def __init__(self, src_file, idx_file):   
        self.data = []
        self.load_src(src_file)
        print(f"Source data {src_file} loaded.")
        self.indexes = None
        self.load_index(idx_file)
        print(f"Index file {idx_file} loaded.")
        self.vocab = []
        # self.word2idx = defaultdict()
        # self.idx2word = defaultdict()
        self.setup()


    def load_src(self, src_file):
        """Load source text data
        """
        with open(src_file, 'r', encoding='GB18030', errors='ignore') as f:
            for line in tqdm(f):
                self.data.append(''.join(line.strip()))

    def load_index(self, idx_file):
        """Load index file of source data which generated by main.py
        """
        f = open(idx_file, 'rb')
        self.indexes = pickle.load(f)
        f.close()

    def setup(self):
        """Some setups when init the class, including make a vocab list
        """
        idxes = defaultdict()
        for item in self.indexes:
            file_tag = list(set(item[2]))
            idxes[item[0]] = sorted(file_tag)
            self.vocab.append(item[0])
        self.indexes = idxes

    def mergetwo(self, p1, p2):
        """Merge 2 list with the same idx
        """
        result = []
        idx1, idx2 = 0, 0
        if not p1:
            return p2
        if not p2:
            return p1
        while idx1 < len(p1) and idx2 < len(p2):
            if p1[idx1] == p2[idx2]:
                result.append(p1[idx1])
                idx1 += 1
                idx2 += 1
            elif p1[idx1] < p2[idx2]:
                idx1 += 1
            else:
                idx2 += 1
        return result

    def intersect(self, candidates, result=None):
        """Implement of boolean search, which needs to satisfy multi query key words
        """
        candidates = [candidate for candidate in candidates if "No Answer" not in candidate]
        if not len(candidates):
            return []
        terms = sorted(candidates, key = lambda x: len(x))
        result = []
        for t in terms:
            result = self.mergetwo(result, t)
        return result

    def clean(self, content):
        """Some clean operations for results
        """
        pattern = '\u3000|\ue40c'
        res = list(map(lambda s: re.sub(pattern, '', s), content))
        res = ''.join(res).replace('<content>', '').replace('</content>', '')
        return res

    def search(self, keywords):
        """Search results given multi key words 
        """
        ans = []
        candidates = []
        result = []
        for key in keywords:
            if key in self.vocab:
                candidates.append(self.indexes[key])
            else:
                candidates.append(["No Answer"])
                # return ["No Answer"]
        if candidates:
            res = self.intersect(candidates)
        if res:
            for r in res:
                result.append(self.clean(self.data[r]))
        return result if result else ["No Answer"]
